use std::fs;
use std::io::{Read, Write};
use std::path::Path;

const CIRCLE_FLAGS_URL: &str = "https://github.com/HatScripts/circle-flags/archive/refs/heads/gh-pages.zip";
const FLAGS_DIR: &str = "assets/flags";
const ICON_SIZE: u32 = 64;

fn main() {
    println!("cargo:rerun-if-changed=build.rs");

    let flags_dir = Path::new(FLAGS_DIR);

    // Download and extract flags if not present
    if !flags_dir.exists() || fs::read_dir(flags_dir).map(|d| d.count()).unwrap_or(0) < 10 {
        download_and_extract_flags(flags_dir);
    }

    // Convert SVGs to PNGs
    convert_svgs_to_pngs(flags_dir);

    // Generate icons module code
    generate_icons_module(flags_dir);
}

fn download_and_extract_flags(flags_dir: &Path) {
    println!("cargo:warning=Downloading circle-flags...");

    fs::create_dir_all(flags_dir).expect("Failed to create flags directory");

    let response = reqwest::blocking::get(CIRCLE_FLAGS_URL)
        .expect("Failed to download circle-flags");

    let bytes = response.bytes().expect("Failed to read response");
    let reader = std::io::Cursor::new(bytes);
    let mut archive = zip::ZipArchive::new(reader).expect("Failed to open zip");

    // Extract only SVG files from flags directory
    for i in 0..archive.len() {
        let mut file = archive.by_index(i).expect("Failed to get zip entry");
        let name = file.name().to_string();

        // Look for SVG files in the flags directory
        if name.contains("/flags/") && name.ends_with(".svg") {
            if let Some(filename) = Path::new(&name).file_name() {
                let dest_path = flags_dir.join(filename);
                let mut dest_file = fs::File::create(&dest_path)
                    .expect("Failed to create SVG file");
                let mut contents = Vec::new();
                file.read_to_end(&mut contents).expect("Failed to read SVG");
                dest_file.write_all(&contents).expect("Failed to write SVG");
            }
        }
    }

    println!("cargo:warning=Circle-flags downloaded successfully");
}

fn convert_svgs_to_pngs(flags_dir: &Path) {
    let entries = fs::read_dir(flags_dir).expect("Failed to read flags directory");

    for entry in entries.flatten() {
        let path = entry.path();
        if path.extension().map(|e| e == "svg").unwrap_or(false) {
            let png_path = path.with_extension("png");

            // Skip if PNG already exists and is newer
            if png_path.exists() {
                let svg_modified = fs::metadata(&path).and_then(|m| m.modified()).ok();
                let png_modified = fs::metadata(&png_path).and_then(|m| m.modified()).ok();
                if let (Some(svg_time), Some(png_time)) = (svg_modified, png_modified) {
                    if png_time > svg_time {
                        continue;
                    }
                }
            }

            if let Err(e) = convert_svg_to_png(&path, &png_path) {
                println!("cargo:warning=Failed to convert {:?}: {}", path, e);
            }
        }
    }
}

fn convert_svg_to_png(svg_path: &Path, png_path: &Path) -> Result<(), Box<dyn std::error::Error>> {
    let svg_data = fs::read(svg_path)?;

    let options = resvg::usvg::Options::default();
    let tree = resvg::usvg::Tree::from_data(&svg_data, &options)?;

    let size = tree.size();
    let scale = ICON_SIZE as f32 / size.width().max(size.height());

    let width = (size.width() * scale) as u32;
    let height = (size.height() * scale) as u32;

    let mut pixmap = resvg::tiny_skia::Pixmap::new(width, height)
        .ok_or("Failed to create pixmap")?;

    let transform = resvg::tiny_skia::Transform::from_scale(scale, scale);
    resvg::render(&tree, transform, &mut pixmap.as_mut());

    pixmap.save_png(png_path)?;

    Ok(())
}

fn generate_icons_module(flags_dir: &Path) {
    let out_dir = std::env::var("OUT_DIR").expect("OUT_DIR not set");
    let dest_path = Path::new(&out_dir).join("icons_data.rs");

    let mut code = String::new();
    code.push_str("// Auto-generated by build.rs - do not edit\n");
    code.push_str("use std::collections::HashMap;\n");
    code.push_str("use std::sync::LazyLock;\n\n");

    let mut flag_names = Vec::new();

    // Generate constants for each PNG
    let entries = fs::read_dir(flags_dir).expect("Failed to read flags directory");
    for entry in entries.flatten() {
        let path = entry.path();
        if path.extension().map(|e| e == "png").unwrap_or(false) {
            if let Some(stem) = path.file_stem().and_then(|s| s.to_str()) {
                let const_name = stem.to_uppercase().replace('-', "_");
                let abs_path = fs::canonicalize(&path).expect("Failed to get absolute path");

                code.push_str(&format!(
                    "pub const FLAG_{}: &[u8] = include_bytes!(\"{}\");\n",
                    const_name,
                    abs_path.display()
                ));

                flag_names.push((stem.to_lowercase(), const_name));
            }
        }
    }

    // Generate lookup map
    code.push_str("\npub static FLAGS: LazyLock<HashMap<&'static str, &'static [u8]>> = LazyLock::new(|| {\n");
    code.push_str("    let mut m = HashMap::new();\n");

    for (code_name, const_name) in &flag_names {
        code.push_str(&format!("    m.insert(\"{}\", FLAG_{});\n", code_name, const_name));
    }

    code.push_str("    m\n});\n");

    fs::write(&dest_path, code).expect("Failed to write icons_data.rs");

    println!("cargo:warning=Generated {} flag icons", flag_names.len());
}
